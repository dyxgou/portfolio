---
import Heading from "@/components/Articles/Heading.astro";
import Picture from "@/components/Articles/Picture.astro";
import Keyword from "@/components/Articles/Keyword.astro";
import GetCommand from "./snippets/GetCommand.astro";
import Commands from "./snippets/Commands.astro";
import SerializeOK from "./snippets/SerializeOK.astro";
import SerializeExampleSet from "./snippets/SerializeExampleSet.astro";
import SerializedExampleSet from "./snippets/SerializedExampleSet.astro";
---

<main class="prose prose-settings text-neutral-600 mt-20">
  <Heading> Preface </Heading>
  <ol class="fraunces text-2xl">
    <li>
      <a href="#introduction">Introduction</a>
    </li>
    <li>
      <a href="#what-is-redis">What and Why is Redis?</a>
    </li>
    <li>
      <a href="#resp">The Redis Serialization Protocol (RESP)</a>
    </li>
    <li>
      <a href="#how-resp-work">How does RESP Work?</a>
    </li>
    <li>
      <a href="#whats-a-parser">What is a Parser?</a>
    </li>
    <li>
      <a href="#whats-a-tokenizer">What is a Tokenizer?</a>
    </li>
  </ol>

  <Heading id="introduction"> Introduction </Heading>
  <p>
    Redis revolutionized the database world by embracing a radical idea:
    <strong>complexity should live in simplicity.</strong> This article is your gateway
    into that philosophy. We'll reverse-engineer Redis starting with a simple <strong
      >TCP Socket</strong
    >, then implementing the Redis Serialization Protocol <strong>(RESP)</strong
    > and supporting the evaluation of core commands all with Golang and simple <strong
      >yet incredible solutions.</strong
    >
    <br />
  </p>
  <p>
    <strong>NOTE: </strong> ðŸ‘‹ This article is for anyone curious about Redis! Rather
    than overwhelming you with 2,000+ lines of code <strong
      >(just testing the clone)</strong
    >, we'll focus on the key algorithms and design ideas that power this clone.
    <br />
    Want to explore the full project? Check the repo <a
      target="_blank"
      rel="noopener noreferrer"
      href="https://github.com/dyxgou/redis">here</a
    >! ðŸš€
  </p>

  <Heading id="what-is-redis"> What and Why is Redis? </Heading>

  <p>
    Before Redis, scaling applications was a paradox. As app usage soared,
    existing infrastructure crumbled under the weight of simple tasks like
    managing shopping carts, user sessions, and real-time leaderboards. These
    often relied on slow disk-bound databases and fragmented caching.
  </p>
  <p>
    Redis provided the breakthrough. It's a <strong>blazingly fast</strong>, <strong
      >in-memory database</strong
    > designed for simplicity: atomic operations, a clean protocol <strong
      >(RESP)</strong
    >, and pure RAM-speed access. By offloading ephemeral data like sessions and
    cached queries, Redis became the crucial enabler for systems to scale beyond
    their <strong>limits.</strong>
  </p>

  <Heading id="resp"> The Redis Serialization Protocol (RESP) </Heading>

  <p>
    Computers communicate like humans at a conference: they establish
    connections (TCP handshakes) and agree on a shared language <strong
      >(RESP).</strong
    >
  </p>
  <p>
    In our conference there's a speaker and all participants are asking
    questions in this RESP language that the speaker answers.
    <br />
    Our <strong>Redis server</strong> is no different than this speaker, and all
    the <strong>Redis clients</strong> are the participants which conversation between
    Server and Client we call it a <strong>Connection.</strong>
  </p>

  <Picture src="/articles/redis-arch.svg" alt="redis arch" size={1024} />

  <Heading id="how-resp-work"> How does RESP Work? </Heading>

  <p>
    Redis works with commands like <strong>GET, SET, INCR, EXISTS.</strong> Each
    of these has its own structure, technically known as <strong
      >grammar.</strong
    >
  </p>
  <p>Let's see some examples of this grammar:</p>

  <GetCommand />

  <p>
    As you can see, the GET command is pretty simple, just the prefix <Keyword
      word="GET"
    />
    followed by a <Keyword word="key" /> argument.
  </p>

  <p>
    As Redis is a <strong>key-value</strong> database, when we use the <strong
      >GET</strong
    > command it returns the <strong>value associated</strong> with that key or <Keyword
      word="nil"
    />
    (nil means the key doesn't hold any value).
  </p>

  <p>Let's see some similar commands:</p>

  <Commands />

  <p>
    These are some of the Redis commands we are going to support.
    <br />
    You will be amazed by how easily we can extend the available commands with the
    help of a
    <strong>Parser</strong>, but we'll get to that later.
  </p>

  <p>
    Now that we know some commands and their grammar, it's time to serialize a
    command!
  </p>

  <p>To serialize a Redis command you need to consider some key aspects:</p>

  <ol>
    <li>A Command is mainly composed of words.</li>
    <li>
      What type of each word <strong>(e.g command, argument, number).</strong>
    </li>
    <li>The total number of words the command has.</li>
    <li>The number of letters a word has.</li>
    <li>
      The separation of each <strong>RESP element</strong> (or part) of the command
      is <strong>\r\n (CRLF)</strong>.
    </li>
  </ol>

  <p>
    Let's see why this is important when serializing the <strong>OK</strong> response
  </p>

  <SerializeOK />

  <p>
    Don't let yourself be intimidated, in fact the serialization just follow the
    last principles we just stablish, let's break it down.
  </p>

  <ol>
    <li>
      The <strong>*</strong> indicates an <strong>Array</strong>, the <Keyword
        word="1"
      /> after it specifies that the Array contains <strong>one element</strong
      >.
    </li>
    <li>
      As discussed earlier <Keyword word="\\r\\n" /> known as <strong
        >CRLF</strong
      > is use to separate between the elements of the command.
    </li>
    <li>
      The <strong>$</strong> indicates that the actual word that follows is a <strong
        >BulkString</strong
      >, the <Keyword word="2" /> after it represents the BulkString has a length
      of <strong>two letters</strong>.
    </li>
    <li>
      <strong>OK</strong> is the actual string data represented by the preceding
      <Keyword word="$2" />.
    </li>
    <li>
      The final <Keyword word="\\r\\n" /> terminates the OK Bulk String element,
      completing the serialized array.
    </li>
  </ol>

  <p>Let's see one more example to understand this concept.</p>

  <SerializeExampleSet />

  <p>Let's think about it.</p>
  <ol>
    <li>
      The command has <strong>3 elements</strong> (<Keyword word="SET" />, <Keyword
        word="userName"
      />, <Keyword word="Alejandro" />) so its serialization should start with
      <Keyword word="*3\\r\\n" />.
    </li>
    <li>
      The first argument is <Keyword word="userName" />, which is a <strong
        >Bulk String</strong
      > of length 8 bytes. So, this part should continue with <Keyword
        word="$8"
      />, and the <strong>argument</strong> itself surrounded by <Keyword
        word="\\r\\n"
      />, being serialized as <Keyword word="$8\\r\\nuserName\\r\\n" />.
    </li>
    <li>
      The second argument follows the same logic as the first one, it's a <strong
        >Bulk String</strong
      > of length 9 bytes. So, it'll be serialized as <Keyword
        word="$9\\r\\nAlejandro\\r\\n"
      />.
    </li>
  </ol>

  <SerializedExampleSet />
  <p>
    At the end we put it all together with its respective separations <strong
      >(\r\n)</strong
    >. If you want to explore the <strong>RESP</strong> specification further, check
    it <a
      target="_blank"
      rel="noopener noreferrer"
      href="https://redis.io/docs/latest/develop/reference/protocol-spec/"
      >here</a
    >! ðŸš€
  </p>

  <p>
    If you're wondering why we're doing all of this, remember tht computers
    communicate with each other in a <strong>shared language</strong>.
    <br />
    This language had to be efficient and as expressive as possible, as this is crucial
    to optimize the Redis <strong>Parser</strong>.
  </p>

  <p>But wait, what is a <strong>Parser</strong>?</p>

  <Heading id="whats-a-parser"> What is a Parser? </Heading>
  <p>
    <strong>Definition:</strong> Parsing is the process of structuring a linear representation
    in accordance with a given grammar.
    <br />
  </p>

  <p>
    WHAT? Even if this definition can sound a little complex, it is, in fact, is
    pretty simple.
    <br />
    A <strong>Linear Representation</strong> can be either a sentence of a language,
    a piece of music, or a Redis Command.
    <br />
    We have mention <strong>grammar</strong> before as the stucture of a sentence,
    or a command, think of it as a formula to get different sentences.
  </p>

  <p>
    So, applied to our use case, <strong>Parsing</strong> is the process of structuring
    a Redis Command in accordance with a given Command <strong>Structure</strong
    >.
  </p>

  <Heading id="whats-a-tokenizer"> What is a Tokenizer? </Heading>

  <p>
    We have been using the term <strong>words</strong>, meaning they are the
    fundamental unit of information in Redis Commands and in texts in general,
    but the technical term is <strong>tokens</strong>, and we will use it from
    now on.
  </p>
</main>
