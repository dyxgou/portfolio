---
import Heading from "@/components/Articles/Heading.astro";
import Keyword from "@/components/Articles/Keyword.astro";
import GetCommand from "./GetCommand.astro";
import PingCommand from "./PingCommand.astro";
import PingTable from "./PingTable.astro";
import Commands from "./Commands.astro";
import SETTable from "./SETTable.astro";
import SerializeExampleSet from "./SerializeExampleSet.astro";
import SerializedExampleSet from "./SerializedExampleSet.astro";
import SerializedGetCommand from "./SerializedGetCommand.astro";
import GetTable from "./GetTable.astro";
---

<Heading id="how-resp-work"> How does RESP Work? </Heading>

<p>
  Redis commands like <Keyword word="GET" />, <Keyword word="SET" />, and <Keyword
    word="PING"
  /> aren't just strings; they follow a specific <strong>grammar</strong>. Letâ€™s
  look at how a simple <Keyword word="PING" /> command is structured in RESP:
</p>

<p><strong>The <Keyword word="PING" /> Command:</strong></p>

<PingCommand />

<p>
  At first glance, this looks like "computer gibberish", but itâ€™s actually a
  highly efficient way to structure a request. In RESP, <strong
    >every command is sent as an Array</strong
  >, even if it only contains a single string.
</p>

<p>Here's the breakdown:</p>

<PingTable />

<p>
  While <Keyword word="PING" /> is a great starting point, most Redis interactions
  involve data. Let's see how to parse a more complex command like <Keyword
    word="GET"
  />.
</p>

<GetCommand />

<p>
  In <strong>RESP</strong>, this is represented as an array of two bulk strings:
</p>

<SerializedGetCommand />

<p>
  At first, this looks significantly more complex, but the logic remains
  identical. We are simply nesting more data inside our Command Array.
</p>

<GetTable />

<p>
  While <Keyword word="PING" /> and <Keyword word="GET" /> provide a solid foundation,
  they only scratch the surface of what we are building.
  <br />
  Here are some examples of other <strong>Redis Commands:</strong>
</p>

<Commands />

<p>
  Later in this article, we will dedicate specific sections to implementing the
  full range of commands. To finish our look at RESP, let's see how the protocol
  scales with a <strong>3-part</strong> command like <Keyword word="SET" />:
</p>

<SerializeExampleSet />

<p>Give it a try before you see the solution.</p>

<SETTable />

<p>
  It might seem a long process but gluing it all together had come to a result.
</p>

<SerializedExampleSet />

<p>
  If you are still confused about how RESP works, I <strong>highly</strong> recommend
  you to consult this Redis article about RESP. You can <a
    target="_blank"
    rel="noopener noreferrer"
    href="https://redis.io/docs/latest/develop/reference/protocol-spec/"
    >find it here</a
  >! ðŸš€
</p>

<p>
  If you're wondering why we're doing all of this, remember that computers
  communicate with each other in a <strong>shared language</strong>.
  <br />
  This language had to be efficient and as expressive as possible, as this is crucial
  to optimize the Redis <strong>Parser</strong>.
</p>

<p>But wait, what is a <strong>Parser</strong>?</p>
