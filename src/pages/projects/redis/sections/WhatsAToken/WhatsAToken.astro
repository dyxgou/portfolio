---
import Heading from "@/components/Articles/Heading.astro";
import Picture from "@/components/Articles/Picture.astro";
import Keyword from "@/components/Articles/Keyword.astro";
import Tokens from "./Tokens.astro";
import TokenStruct from "./TokenStruct.astro";
---

<Heading id="whats-a-token"> What is a Token? </Heading>

<p>
  A <strong>Token</strong> is the smallest atomic unit of a command. Think of them
  as the fundamental building blocksâ€”like verbs (<Keyword word="GET" />) and
  nouns (<Keyword word="mykey" />) â€”that our parser uses to reconstruct a
  clientâ€™s command.
</p>

<p>There are several kinds of tokens in our system:</p>

<ul>
  <li>
    <strong>Commands:</strong> The instructions (e.g., <Keyword word="GET" />, <Keyword
      word="SET"
    />, <Keyword word="PING" />).
  </li>

  <li>
    <strong>Identifiers:</strong> The keys or values (e.g., <Keyword
      word="userName"
    />, <Keyword word="Alejandro" />).
  </li>

  <li>
    <strong>Numbers:</strong> Numeric values used in operations (e.g., <Keyword
      word="100"
    />).
  </li>
</ul>

<Picture src="/articles/token-example.svg" alt="Command tokens" size={1024} />

<p>
  As shown in the diagram above, the command <Keyword
    word="SET userName Alejandro"
  /> is not treated as <strong>one long string</strong>. Instead, the <strong
    >Lexer</strong
  >
  identifies three distinct tokens: a specific <Keyword word="SET" /> command followed
  by two <Keyword word="Identifiers" />.
</p>

<h3 class="underline">Defining Token Kinds</h3>

<p>
  Now that weâ€™ve defined the concept of a Token, we need a way to categorize
  them in our code. In Go, we do this using <Keyword word="Enums" /> (enumerated
  constants).
</p>

<p>
  We will create a <Keyword word="TokenKind" /> type to represent every possible
  category our parser might encounterâ€”such as <strong
    >Commands, Identifiers, or Numbers.</strong
  >
  By using Go's <Keyword word="iota" /> keyword, we can efficiently assign unique,
  incremental values to each kind, starting with technical markers like <Keyword
    word="EOF"
  /> (End of File) and <Keyword word="ILLEGAL" /> (for unknown characters).
</p>

<Tokens />

<strong
  >Why use a <Keyword word="byte" /> for <Keyword word="TokenKind" />?</strong
>

<p>
  You might wonder why we chose a <Keyword word="byte" /> instead of a <Keyword
    word="string"
  /> or a standard <Keyword word="int" />. There are two primary engineering
  reasons:
</p>

<ol>
  <li>
    <strong>Memory Efficiency:</strong> Since our Lexer will generate a new instance
    for every single <strong>word</strong> or <strong>symbol</strong> in a command,
    using a <strong>1-byte</strong> type keeps our memory footprint as small as possible.
  </li>
  <li>
    <strong>Sufficient Capacity:</strong> A <Keyword word="byte" /> ( an alias for
    <Keyword word="uint8" /> ) can represent up to 256 unique values. Since our Redis
    clone will only have a few dozen command types and symbols, this is the perfect,
    lightweight fit for our <Keyword word="TokenKind" />.
  </li>
</ol>

<p>
  Knowing this, we need a container to hold both the <Keyword
    word="TokenKind"
  /> of the token and the raw data it represents, called the <Keyword
    word="Literal"
  />.
</p>

<TokenStruct />

<p>The <Keyword word="Token" /> struct is composed of:</p>

<ol>
  <li>
    <Keyword word="Literal" />: The raw string value extracted from the input
    (e.g., <Keyword word="GET" /> or <Keyword word="mykey" />).
  </li>
  <li>
    <Keyword word="Kind" />: The TokenKind (our byte-sized Enum) that tells the
    parser how to interpret that literal.
  </li>
</ol>

<p>
  ðŸ”¥ <strong>Fun Fact:</strong> Even thought i just said that the <Keyword
    word="Token"
  /> struct should be as lightweight as possible, this is not the most lightweight
  representation for a Token.
  <br />

  The <strong>Golang Parser</strong> uses an amazing technique: instead of storing
  a piece of text in the struct as we do, they just store the <strong
    >indices</strong
  > from where the piece of text beings and ends, a simple and ingenious trick if
  you want to implement it, <a
    target="_blank"
    rel="noopener noreferrer"
    href="https://github.com/golang/go/blob/3fd729b2a14a7efcf08465cbea60a74da5457f06/src/go/token/position.go#L83"
    >Check the details here</a
  >.
</p>

<p>
  But now that we have defined our tokens <strong>it's time</strong> to use them!
</p>
